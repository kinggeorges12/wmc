geo $dollar {
    default "$";
}

server {
    # https://docs.jellyseerr.dev/extending-jellyseerr/reverse-proxy?nginx-reverse-proxy=subfolder
    listen 80;

    location / {
        # Always return 204 No Content
        return 204;
    }

    location ~ ^/jellyseerr/jellyseerr {
        set $app 'jellyseerr';
        set $public_url '***REMOVED: example.ddns.com:443***';

        # Remove /jellyseerr path to pass to the app
        rewrite ^/jellyseerr/jellyseerr/(.*)$ /$1 break;
        proxy_pass http://host.docker.internal:5055;
    }

    # Must appear first in priority for regex
    location ~ ^/jellyseerr/api/v1/user/[0-9]+/settings/password {
        # Block users from changing passwords
        content_by_lua_block {
            if ngx.var.request_method ~= "GET" then
                return ngx.exit(401)
            else
                return ngx.exec("@jellyseerr_backend")
            end
        }
    }

    location ~ ^/jellyseerr {
        content_by_lua_block {
            return ngx.exec("@jellyseerr_backend")
        }
    }

    location ^~ /jellyseerr/api/v1/auth/reset-password {
        # Block users from password resets
        content_by_lua_block {
            if ngx.var.request_method ~= "GET" then
                return ngx.exit(401)
            else
                return ngx.exec("@jellyseerr_backend")
            end
        }
    }

    # Auto-login via Jellyfin username (check Jellyfin nginx for setting the cookie)
    location ^~ /jellyseerr/login {
        # https://github.com/ledgetech/lua-resty-http?tab=readme-ov-file#single-shot-request
        content_by_lua_block {
            local cookie_name = "UserName"
            local ck = ngx.var.http_cookie or ""
            ngx.log(ngx.DEBUG, "[Auto-login] http_cookie: ", ck)

            -- Helper: extract a specific cookie by name
            local function get_cookie(name)
                ngx.log(ngx.DEBUG, "[Auto-login] get_cookie: ", name)
                local pattern = name .. "=([^;]+)"
                return ck:match(pattern)
            end

            -- Check if user has already connected
            local connect_sid = get_cookie("connect.sid")
            if connect_sid then
                -- Cookie exists, just proxy to backend
                ngx.log(ngx.INFO, "[Auto-login] Previous cookie found: ", connect_sid)
                ngx.header["Set-Cookie"] = cookie
                return ngx.exec("@jellyseerr_backend")
            else
                -- get UserName cookie
                local UserName = get_cookie(cookie_name)
                if UserName and not connect_sid then
                    ngx.log(ngx.INFO, "[Auto-login] Found user: ", UserName)

                    local function read_string(filename)
                        local f = assert(io.open(filename, "r"))
                        local data = f:read("*a")   -- read entire file
                        f:close()
                        return data:gsub("%s+$", "")  -- trim trailing newlines/whitespace
                    end
                    -- get user password
                    local password = read_string("/home/password.txt")

                    local httpc = require("resty.http").new()
                    httpc:set_timeout(30000) -- 30s timeout
                    httpc:set_keepalive(0)

                    -- Single-shot requests use the request_uri interface.
                    local res, err = httpc:request_uri("http://host.docker.internal:5055/api/v1/auth/local", {
                        method = "POST",
                        body = '{"email":"' .. UserName .. '","password":"' .. password .. '"}',
                        headers = {
                            ["Content-Type"] = "application/json",
                        },
                    })

                    -- Error codes
                    if not res then
                        ngx.status = ngx.HTTP_UNAUTHORIZED
                        ngx.header["Content-Type"] = "text/html; charset=utf-8"
                        ngx.say("<!DOCTYPE html><html><head></head><body></body></html>")
                        ngx.exit(ngx.HTTP_UNAUTHORIZED)
                    end

                    -- Read response body
                    ngx.log(ngx.DEBUG, "[Auto-login] request body: ", res.body)

                    -- Set the returned cookie
                    local cookie = res.headers["Set-Cookie"]
                    ngx.log(ngx.DEBUG, "[Auto-login] request cookie: ", cookie)
                    if cookie then
                        ngx.header["Set-Cookie"] = cookie
                    end

                    -- Clear the cookie
                    --ngx.header["Set-Cookie"] = cookie_name .. "=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; HttpOnly"
                    -- Reload the page so the browser sends the cookie
                    ngx.redirect("/jellyseerr")
                else
                    ngx.log(ngx.ERR, "[Auto-login] User cookie not found. Check Jellyfin config to make sure the Username cookie is set.")
                end

                -- Non-terminating error or end of the script, continue serving the login page
                return ngx.exec("@jellyseerr_backend")
            end
        }
    }

    # Auto-login cancelled on logout
    location ^~ /jellyseerr/api/v1/auth/logout {
        content_by_lua_block {
            -- Clear the cookie
            local cookie_name = "connect.sid"
            ngx.header["Set-Cookie"] = cookie_name .. "=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; HttpOnly"
            ngx.log(ngx.INFO, "[Auto-login] " .. cookie_name .. " cookie cleared: ", cookie_name)
            -- Clear the cookie
            local cookie_name = "UserName"
            ngx.header["Set-Cookie"] = cookie_name .. "=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT; HttpOnly"
            ngx.log(ngx.INFO, "[Auto-login] " .. cookie_name .. " cookie cleared: ", cookie_name)
            -- Continue with response
            return ngx.exec("@jellyseerr_backend")
        }
    }

    # Handle requests from /jellyseerr
    location @jellyseerr_backend {
        set $app jellyseerr;
        set $public_url ***REMOVED: example.ddns.com:443***;

        # Remove /jellyseerr path to pass to the app
        rewrite ^/jellyseerr/?(.*)$ /$1 break;
        proxy_pass http://host.docker.internal:5055; # NO TRAILING SLASH

        # Rewrite redirect headers from the app
        proxy_redirect ~^/jellyseerr$ $public_url/$app;
        proxy_redirect ~^/(jellyseerr/)+(.*)$ $public_url/$app/$2;
        proxy_redirect ~^/(?!jellyseerr)(.*)$ $public_url/$app/$1;

        # Capture the referer
        if ($http_referer ~* "^https?://[^/]+(/.*)") {
            set $referer_path $1;
        }
        # If empty
        if ($referer_path = "") {
            set $referer_path ""; # TODO: or should it be /
        }
        # Prepend /jellyseerr if not already present
        if ($referer_path !~ "^/jellyseerr") {
            set $referer_path /jellyseerr$referer_path;
        }
        proxy_set_header Referer $scheme://$host$referer_path;

        # Websockets
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 600s;
        proxy_send_timeout 600s;
        # Generic reverse proxy
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Sub filters to replace hardcoded paths
        proxy_set_header Accept-Encoding "";
        sub_filter_once off;
        # Excludes text/html, which is used for manifests
        sub_filter_types text/javascript text/css application/javascript image/svg+xml application/json application/manifest+json;
        #sub_filter_types *;
        sub_filter '\/_next' '\/${app}\/_next';
        sub_filter '/_next' '/${app}/_next';
        sub_filter 'href="/"' 'href="/${app}"';
        sub_filter 'href:"/"' 'href:"/${app}"';
        sub_filter 'href="/login"' 'href="/${app}/login"';
        sub_filter 'href:"/login"' 'href:"/${app}/login"';

        # Rewrite
        sub_filter 'href="/discover"' 'href="/${app}/discover"';
        sub_filter 'href="/discover/movies"' 'href="/${app}/discover/movies"';
        sub_filter 'href:"/discover/movies"' 'href:"/${app}/discover/movies"';
        sub_filter 'href="/discover/tv"' 'href="/${app}/discover/tv"';
        sub_filter 'href:"/discover/tv"' 'href:"/${app}/discover/tv"';
        sub_filter 'href="/requests"' 'href="/${app}/requests"';
        sub_filter 'href:"/requests"' 'href:"/${app}/requests"';
        sub_filter 'href="/blacklist"' 'href="/${app}/blacklist"';
        sub_filter 'href:"/blacklist"' 'href:"/${app}/blacklist"';
        sub_filter 'href="/issues"' 'href="/${app}/issues"';
        sub_filter 'href:"/issues"' 'href:"/${app}/issues"';
        sub_filter 'href="/users' 'href="/${app}/users';
        sub_filter 'href:"/users' 'href:"/${app}/users';
        # Needed for profile pages to reload sub-pages like /profile/settings
        sub_filter '"/profile' '"/${app}/profile';

        sub_filter '/api/v1' '/${app}/api/v1';
        sub_filter '/login/plex/loading' '/${app}/login/plex/loading';
        sub_filter '/images/' '/${app}/images/';
        sub_filter '/imageproxy/' '/${app}/imageproxy/';
        sub_filter '/avatarproxy/' '/${app}/avatarproxy/';
        sub_filter '/android-' '/${app}/android-';
        sub_filter '/apple-' '/${app}/apple-';
        sub_filter '/favicon' '/${app}/favicon';
        sub_filter '/logo_' '/${app}/logo_';
        sub_filter '/site.webmanifest' '/${app}/site.webmanifest';
        sub_filter '/sw.js' '/${app}/sw.js';
        sub_filter '/os_icon.svg' '/${app}/os_icon.svg';
        sub_filter '/offline.html' '/${app}/offline.html';

        # These routes cause issues with the app manifest
        #sub_filter '\/requests' '\/${app}\/requests';
        #sub_filter '\/issues/' '\/${app}\/issues/';
        #sub_filter '\/blacklist/' '\/${app}\/blacklist/';
        #sub_filter '\/users/' '\/${app}\/users/';
        #sub_filter '\/(discover\/?)' '\/${app}\/(discover\/?)';
        #sub_filter '\/discover\/movies${dollar}/' '\/${app}\/discover\/movies${dollar}/';
        #sub_filter '"page":"/discover/tv"' '"page":"/${app}/discover/tv"';
        #sub_filter '\/discover\/tv${dollar}/' '\/${app}\/discover\/tv${dollar}/';
    }

    # This must appear first for precidence. Not setup properly, but could be used to rewrite manifest files
    #location ~ ^/jellyseerr/.*/_buildManifest\.js$ {
    location @buildManifest {
        set $app 'jellyseerr';
        set $public_url '***REMOVED: example.ddns.com:443***';

        # Remove /jellyseerr path to pass to the app
        rewrite ^/jellyseerr/jellyseerr/(.*)$ /$1 break;
        proxy_pass http://host.docker.internal:5055;

        # Rewrite redirect headers from the app
        proxy_redirect ~^/jellyseerr$ $public_url/$app;
        proxy_redirect ~^/(jellyseerr/)+(.*)$ $public_url/$app/$2;
        proxy_redirect ~^/(?!jellyseerr)(.*)$ $public_url/$app/$1;

        # Capture the referer
        if ($http_referer ~* "^https?://[^/]+(/.*)") {
            set $referer_path $1;
        }
        # If empty
        if ($referer_path = "") {
            set $referer_path ""; # TODO: or should it be /
        }
        # Prepend /jellyseerr if not already present
        if ($referer_path !~ "^/jellyseerr") {
            set $referer_path /jellyseerr$referer_path;
        }
        proxy_set_header Referer $scheme://$host$referer_path;

        # Websockets
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_cache_bypass $http_upgrade;
        proxy_read_timeout 600s;
        proxy_send_timeout 600s;
        # Generic reverse proxy
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # Sub filters to replace hardcoded paths
        proxy_set_header Accept-Encoding "";
        sub_filter_once off;
        sub_filter_types *;

        sub_filter '"/' '"/${app}/';
    }

}
